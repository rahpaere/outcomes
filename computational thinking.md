# Computational thinking

## Know what you would make with computers if you could.  (Self in relation to world)

- Develop a personal style of pseudocode.
- Collaborate with computers as alien intelligences, utilizing digital logic.

## See the world outside of class in terms of computing and its precepts. (Computing in relation to world)

- creating algorithms
- problem solving and heuristics
- Use pseudocode as a way to write and think about algorithms, and to translate between algorithms and programs.
- requirements and specification of non-programming problems, abstraction
- think like a computer, think like a human, choose and adapt modes of thought.
- Apply computer-based ways of problem-solving, representing, explaining, mediating reality, answering questions, communicating, etc. outside the context of computers.
- Apply collaboration with alien strengths and weaknesses of computers to cooperating with unique humans.
- abstract search space
- constructivist theory of learning, Mindstorms by Papert, Origins of Intelligence by Piaget

## Participate in computing as a discipline and course of study. (Computing in relation to self)

- Describe CS as a degree program—what it is, what courses there are—and draw distinctions between subfields.
- Describe CS careers.
- Describe major fields of study in CS with some familiarity.
  - programming languages
  - databases
  - graphics
  - AI, robotics, and machine learning
  - theory
  - data science
  - operating systems
  - networking
  - architecture
- Establishing a Kuhnic paradigm
  - History of mathematicians, Lovelace & Babbage, ENIAC, Harvard Mark I, computing scientists, discoveries
  - Combinatorial puzzles (river crossing, tower of Hanoi, knights/knaves)
  - scientific method, Philosophy of science, Kant, Wittgenstein, Kuhn
  - affective domain learning of code of conduct
- Quine—naming, quoting, quantifying, use/mention
- represent program as a graph with control flow edges (flow chart) or data flow edges (dataflow programming, logic circuit diagrams)
- time as an abstraction—clocks, timestamps, runtime, and ordering of events
- Information theory
  - bit as unit of information, logarithmic measure of surprise
  - isomorphism
  - coding as bitstrings (dichotomy, false dichotomy, powers of two, 20 questions, dice, coins, Venn diagrams, tables, graphs, etc.)
    - letters (game tree/decision tree metaphor, divide-by-2 strategy, Huffman coding)
    - Natural numbers (binary, other bases, abacus metaphor) (number theory)
    - numeral systems
    - Integers (offset, sign/magnitude, BCD, one's complement, two's complement)
    - colors, playing cards, etc.
    - raster images, vector images
    - audio
    - video
    - memory/arrays, linked lists
