# Programming

The following outcomes are existentially quantified over development environment, including language, libraries, platforms, and tools. If a student demonstrates this level of proficiency in any environment, a school may accept that for awarding the ASOT-CS, while a school accepting the ASOT-CS for transfer may require a student to demonstrate proficiency in a particular environment. The student being able to adapt to a new environment, given support and documentation but largely independently, is among the outcomes below.

## Write and execute a program.

- Write a program using tools such as editor and version control system.
- Execute a program using tools such as interpreter, compiler, and build system.
- Decompose a program into modules at a source file level. Organize source files in a filesystem, using any relevant language features (e.g. including headers or importing modules) and build systems (e.g. separate compilation, library linking, or make).
- Write and execute some introductory program (such as hello world) from experience, without external references.

## Adapt to a new develepment environment.

- Recognize patterns in programming languages, documentation, tools, etc., to make it easier to move between contexts (courses, employers, projects, etc.) that use different development environments.
- Adapt to the style guidelines of an existing codebase.

## Discuss computing problems among humans.

- Use language reference documentation, tutorials, style guides, fora, IRC, mailing lists, user groups, conferences, etc.
- Value consistent programming style and use a consistent personal style.
- Explain requirements, design decisions, and coding decisions, using source code (variable names, conventions, etc.), programming comments, and documentation.
- Read existing code and explain what it does and how.
- Discuss source code with other humans, such as during code review or pair programming.
- Collaborate with other students, and learn from example code, in a way that avoids plagiarism.

## Reason about values in a program.

- Distinguish a value, a location that stores a value, and an identifier that names a location or value.
- Use references to data, such as a pointer whose value represents the location of the data, or a reference which may be an alias for another identifier for the data. Reason about aliasing.
- Determine whether an identifier in a program is a variable, which might hold more than one value over the running of the program, or a constant, which always has a fixed value. Use provided features for distinguishing variables and constants.
- Assign appropriate scope and lifetime to each variable in a program. Use provided features for annotating scope and lifetime.
- Analyze an identifier for type, that is, the set of values it might hold and properties all those values have in common. Use provided features for annotating types.

## Represent the data from a real-world problem domain within a program.

- Use provided Booleans and logical operators and relations.
- Use provided numbers (including naturals, integers, and rationals), arithmetic operators, and ordering relations.
- Manipulate bits within number representations, using bitwise operators, masking, shifting, etc.
- Use provided product datatypes, such as record, struct, tuple, named tuple, object attributes, etc.
- Use provided sum datatypes, such as enum, union, optional/maybe, etc.
- Use provided text datatypes (i.e. strings).
- Write programs that correctly handle character sets, text encoding, internationalization, and localization.
- Use provided sequential data structures, such as arrays.
- Use provided mapping data structures, such as maps/dictionaries and records/structures/named tuples/objects.

## Connect a program with its environment.

- Access arguments and options provided when a program is run, i.e. command-line arguments and environment variables.
- Read and write data on standard streams such as a console.
- Read and write files in external storage.

## Apply structured programming principles.

- Decompose a program into blocks of sequential code, functions, and procedures.
- Distinguish statements and expressions, and discuss the side-effects of expressions.
- Use provided conditional/selection statements.
- Use provided iteration/repetition/looping statements.

## Apply object-oriented programming principles.

- Decompose a program into objects that encapsulate state and behavior.
- Connect objects using composition and messages/methods, while using provided features to hide internal details of data representation.
- Extend and reuse parts of a program, using provided features for inheritance, polymorphism, and genericity.
- Distinguish static and dynamic dispatch, use provided features for both, and justify deciding between them.
- Use libraries written using object-oriented programming in a correct, idiomatic way.

## Apply generic programming principles.

- Lift an algorithm from multiple, concrete implementations for different kinds of values, to a single, generic implementation that abstracts away their differences.
- When lifting an algorithm, state explicitly what common features of the values are required for the generic implementation to be correct and avoid sacrificing efficiency.
- Given a family of generic algorithms, organize their requirements using explicit, named concepts.
- When appropriate, specialize a generic algorithm with multiple versions that have different requirements.
- Recognize STL Iterator concepts.
